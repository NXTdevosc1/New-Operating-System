TODO : AddressMap, SizeMap
TODO : Create bytecode instead of recursive tree searching


This is the kernel mode version of optimized the heap manager

Features :

-

Algorithm :
Init(Image, AddressSpaceSize, UnitSize, AllocateSource, {InitialHeap}) -> HM Will initialize the required values in the Image

- Free/allocated memory are in different sorted bitmap trees with indexed access
- So instead of using an array of pointers to different tree, we use bitmaps and the location of the tree is determined via indexes

_AllocateVaSpace(Index) -> Allocates a page and maps it


HmCalculateAddressSpace(AdressSpaceSize, UINT64 UnitSize) -> {
    {AdressSpaceSize is in 1 byte units, and doesn't follow unitsize}
    {AddressSpaceSize should be aligned with unitsize}
    - Calculates required address space for the whole HMIMAGE to work
    - the address space consists of the first page + array of bitmaps
    - The caller should only allocate the first page in the address space and leave the rest for the heap manager
}

_HmAllocateWithoutHeap(INT64 Units) -> {
    - (Independent feature) (HM Does not use spinlocks often)
    - Find first heap
    - exchange add (Special atomic instruction)
    - if heap size < 0 then the size is unsufficient, re-increment size and return NULL
    - else return the address;
}

HmAllocate(INT64 Units){
    - addr = _HmAllocateWithoutHeap(Image, Units)
    - Heap = _HmAllocateWithoutHeap(Image->AllocateSource, sizeof Heap)
    - Put heap in the allocated memory bitmap
}

HmFree(Address) {
    Very easy, look if the entry corresponding to the bitmap is present the allocated memory bitmap tree
    - then link it to last heap, so that heaps keep sorting themselves
    - Until we get the initial heap reformed again, then we will call a special InitialHeapFreed Handler
    - Probably, the handler will unmap the heap from the process
}